From 7d706e0f4114f31f7eb1bc7e2f02d79f86c136d7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Enrique=20Oca=C3=B1a=20Gonz=C3=A1lez?= <eocanha@igalia.com>
Date: Mon, 6 Jun 2022 20:56:35 +0200
Subject: [PATCH 1/3] Revert "Manual revert of bfd0e022 qtdemux: rework segment
 event pushing"

This reverts commit e0d65818e8254e441b9652b525ae18d6d08f5542.
---
 gst/isomp4/qtdemux.c | 78 +++++++++++---------------------------------
 gst/isomp4/qtdemux.h |  7 ++--
 2 files changed, 24 insertions(+), 61 deletions(-)

diff --git a/gst/isomp4/qtdemux.c b/gst/isomp4/qtdemux.c
index 47bd6fe83..effc505a5 100644
--- a/gst/isomp4/qtdemux.c
+++ b/gst/isomp4/qtdemux.c
@@ -2152,9 +2152,6 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     qtdemux->element_index = NULL;
 #endif
     qtdemux->major_brand = 0;
-    if (qtdemux->pending_newsegment)
-      gst_event_unref (qtdemux->pending_newsegment);
-    qtdemux->pending_newsegment = NULL;
     qtdemux->upstream_format_is_time = FALSE;
     qtdemux->upstream_seekable = FALSE;
     qtdemux->upstream_size = 0;
@@ -2177,6 +2174,7 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
   qtdemux->offset = 0;
   gst_adapter_clear (qtdemux->adapter);
   gst_segment_init (&qtdemux->segment, GST_FORMAT_TIME);
+  qtdemux->need_segment = TRUE;
 
   if (hard) {
     qtdemux->segment_seqnum = GST_SEQNUM_INVALID;
@@ -2218,12 +2216,6 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
       stream->time_position = 0;
       stream->accumulated_base = 0;
     }
-    if (!qtdemux->pending_newsegment) {
-      qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-      if (qtdemux->segment_seqnum != GST_SEQNUM_INVALID)
-        gst_event_set_seqnum (qtdemux->pending_newsegment,
-            qtdemux->segment_seqnum);
-    }
   }
 }
 
@@ -2318,12 +2310,7 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
       GST_DEBUG_OBJECT (demux, "received newsegment %" GST_SEGMENT_FORMAT,
           &segment);
 
-      /* erase any previously set segment */
-      gst_event_replace (&demux->pending_newsegment, NULL);
-
       if (segment.format == GST_FORMAT_TIME) {
-        GST_DEBUG_OBJECT (demux, "new pending_newsegment");
-        gst_event_replace (&demux->pending_newsegment, event);
         demux->upstream_format_is_time = TRUE;
         demux->segment_seqnum = gst_event_get_seqnum (event);
       } else {
@@ -2400,16 +2387,8 @@ gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 
       /* map segment to internal qt segments and push on each stream */
       if (QTDEMUX_N_STREAMS (demux)) {
-        if (demux->fragmented) {
-          GstEvent *segment_event = gst_event_new_segment (&segment);
-
-          gst_event_replace (&demux->pending_newsegment, NULL);
-          gst_event_set_seqnum (segment_event, demux->segment_seqnum);
-          gst_qtdemux_push_event (demux, segment_event);
-        } else {
-          gst_event_replace (&demux->pending_newsegment, NULL);
-          gst_qtdemux_map_and_push_segments (demux, &segment);
-        }
+        demux->need_segment = TRUE;
+        gst_qtdemux_check_send_pending_segment (demux);
       }
 
       /* clear leftover in current segment, if any */
@@ -4380,6 +4359,12 @@ qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);
       stream->time_position = min_dts;
     }
+
+    /* Before this code was run a segment was already sent when the moov was
+     * parsed... which is OK -- some apps (mostly tests) expect a segment to
+     * be emitted after a moov, and we can emit a second segment anyway for
+     * special cases like this. */
+    qtdemux->need_segment = TRUE;
   }
 
   qtdemux->first_moof_already_parsed = TRUE;
@@ -6915,7 +6900,7 @@ gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
 static void
 gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
 {
-  if (G_UNLIKELY (demux->pending_newsegment)) {
+  if (G_UNLIKELY (demux->need_segment)) {
     gint i;
 
     if (!demux->upstream_format_is_time) {
@@ -6928,6 +6913,8 @@ gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
       gst_qtdemux_push_event (demux, segment_event);
     }
 
+    demux->need_segment = FALSE;
+
     /* clear to send tags on all streams */
     for (i = 0; i < QTDEMUX_N_STREAMS (demux); i++) {
       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);
@@ -7227,15 +7214,6 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
               if (demux->moov_node)
                 g_node_destroy (demux->moov_node);
               demux->moov_node = NULL;
-            } else {
-              /* prepare newsegment to send when streaming actually starts */
-              if (!demux->pending_newsegment) {
-                demux->pending_newsegment =
-                    gst_event_new_segment (&demux->segment);
-                if (demux->segment_seqnum != GST_SEQNUM_INVALID)
-                  gst_event_set_seqnum (demux->pending_newsegment,
-                      demux->segment_seqnum);
-              }
             }
 
             demux->last_moov_offset = demux->offset;
@@ -7254,8 +7232,7 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
 
             demux->got_moov = TRUE;
 
-            gst_event_replace (&demux->pending_newsegment, NULL);
-            gst_qtdemux_map_and_push_segments (demux, &demux->segment);
+            gst_qtdemux_check_send_pending_segment (demux);
 
             if (demux->moov_node_compressed) {
               g_node_destroy (demux->moov_node_compressed);
@@ -7338,20 +7315,15 @@ gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
               ret = GST_FLOW_ERROR;
               goto done;
             }
+
             /* in MSS we need to expose the pads after the first moof as we won't get a moov */
             if (demux->mss_mode && !demux->exposed) {
-              if (!demux->pending_newsegment) {
-                GST_DEBUG_OBJECT (demux, "new pending_newsegment");
-                demux->pending_newsegment =
-                    gst_event_new_segment (&demux->segment);
-                if (demux->segment_seqnum != GST_SEQNUM_INVALID)
-                  gst_event_set_seqnum (demux->pending_newsegment,
-                      demux->segment_seqnum);
-              }
               QTDEMUX_EXPOSE_LOCK (demux);
               qtdemux_expose_streams (demux);
               QTDEMUX_EXPOSE_UNLOCK (demux);
             }
+
+            gst_qtdemux_check_send_pending_segment (demux);
           } else {
             GST_DEBUG_OBJECT (demux, "Discarding [moof]");
           }
@@ -13139,14 +13111,6 @@ qtdemux_update_streams (GstQTDemux * qtdemux)
       stream->stream_tags = NULL;
       if (!gst_qtdemux_add_stream (qtdemux, stream, list))
         return FALSE;
-
-      /* New segment will be exposed at _update_segment in case of pull mode */
-      if (!qtdemux->pending_newsegment && !qtdemux->pullbased) {
-        qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-        if (qtdemux->segment_seqnum)
-          gst_event_set_seqnum (qtdemux->pending_newsegment,
-              qtdemux->segment_seqnum);
-      }
     }
   }
 
@@ -13171,6 +13135,7 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
     }
 
     g_ptr_array_set_size (qtdemux->old_streams, 0);
+    qtdemux->need_segment = TRUE;
 
     return GST_FLOW_OK;
   }
@@ -13189,13 +13154,6 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
       if (!gst_qtdemux_add_stream (qtdemux, stream, list))
         return GST_FLOW_ERROR;
 
-      /* New segment will be exposed at _update_segment in case of pull mode */
-      if (!qtdemux->pending_newsegment && !qtdemux->pullbased) {
-        qtdemux->pending_newsegment = gst_event_new_segment (&qtdemux->segment);
-        if (qtdemux->segment_seqnum)
-          gst_event_set_seqnum (qtdemux->pending_newsegment,
-              qtdemux->segment_seqnum);
-      }
     }
   }
 
@@ -13239,6 +13197,8 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
   g_ptr_array_foreach (qtdemux->active_streams,
       (GFunc) qtdemux_do_allocation, qtdemux);
 
+  qtdemux->need_segment = TRUE;
+
   qtdemux->exposed = TRUE;
   return GST_FLOW_OK;
 }
diff --git a/gst/isomp4/qtdemux.h b/gst/isomp4/qtdemux.h
index ccee2ee2b..83a050a43 100644
--- a/gst/isomp4/qtdemux.h
+++ b/gst/isomp4/qtdemux.h
@@ -118,8 +118,11 @@ struct _GstQTDemux {
   /* configured playback region */
   GstSegment segment;
 
-  /* The SEGMENT_EVENT from upstream *OR* generated from segment (above) */
-  GstEvent *pending_newsegment;
+  /* PUSH-BASED only: If the initial segment event, or a segment consequence of
+   * a seek or incoming TIME segment from upstream needs to be pushed. This
+   * variable is used instead of pushing the event directly because at that
+   * point we may not have yet emitted the srcpads. */
+  gboolean need_segment;
 
   guint32 segment_seqnum;
 
-- 
2.34.1

